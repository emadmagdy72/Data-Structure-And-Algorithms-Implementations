# Data Structures and Algorithms Implementation
This repository contains Python implementations of fundamental data structures and algorithms.

## Implemented Topics
### Data Structures
**Doubly Linked List**: A versatile linked list implementation where each node contains a data element and two pointers, one to the next node and one to the previous node. This structure allows for efficient traversal in both directions.

**Stack**: A Last-In-First-Out (LIFO) data structure that follows the principle of pushing elements onto the stack and popping them off. Essential for applications such as parsing expressions and managing function calls.

**Queue**: A First-In-First-Out (FIFO) data structure that stores elements in a linear order. Perfect for scenarios where order needs to be preserved, like task scheduling.

**Graph Traversal**:

**Depth-First Search (DFS)**: A graph traversal algorithm that explores as far as possible along each branch before backtracking. It's often used for topological sorting and connected component analysis.

**Breadth-First Search (BFS)**: This algorithm explores a graph level by level, making it ideal for shortest path calculations and network analysis.

**Tree Traversal Techniques**:

**Inorder**: Traverse the left subtree, visit the root, then traverse the right subtree.
**Postorder**: Traverse the left subtree, traverse the right subtree, then visit the root.
**Preorder**: Visit the root, traverse the left subtree, then traverse the right subtree.
**Divide and Conquer**
**Min_Max**: An optimization strategy that breaks down a problem into smaller subproblems, solves them independently, and combines the solutions to the original problem. Applied here to efficiently find both the minimum and maximum elements in an array.

**Karatsuba for Multiplication**: A fast multiplication algorithm for large numbers, utilizing a divide-and-conquer approach.

**Sorting Algorithms**:

**Merge Sort**: A divide-and-conquer algorithm that recursively divides the array into two halves, sorts them, and then merges them.
**Quick Sort**: Another divide-and-conquer algorithm that partitions the array and recursively sorts each partition.
**Dynamic Programming**
**Fibonacci**: Solving the Fibonacci sequence efficiently using dynamic programming, where overlapping subproblems are solved only once and results are cached for future use.

**Matrix Multiplication**: Employing dynamic programming to optimize the multiplication of matrices through the efficient computation of subproblems.

**Greedy Algorithms**
**Fractional Knapsack**: A strategy for selecting items in a knapsack to maximize the total value, taking fractions of items if needed.

**Job Sequence**: A greedy algorithm for scheduling jobs based on their deadlines and profits, aiming to maximize the overall profit.
